The difference between instruction addu from our experiment with adding 0x70000000 to itself, and the instruction add 0x70000000 to itself is that with addu the result is simply incorrect due overflow from being a very large positive value (+1.8 billion) summed with itself to a negative (-536 million). Versus with the add instruction, mips did not perform the calculation, instead yielded a warning that arithmetic overflow has occurred and does not continue the program from there. One traps on overflow, the other does not is the biggest difference between the signed and unsigned addition instruction. I would much rather it give wrong results than to trap the program. On smaller values that would not overflow the instructions add and addu appear to work in the same way. 